generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    id            String   @id @default(uuid())
    username      String?  @unique // New field: required and unique
    email         String?  @unique
    password      String? // bcrypt hashed; null if user hasn't completed binding
    authMethod    String? // e.g. 'credentials' or 'oauth'
    walletAddress String?  @unique
    userType      UserType @default(normal)
    createdAt     DateTime @default(now())
    lastLogin     DateTime @updatedAt
    contactInfo   String

    // User relationships
    createdCampaigns Campaign[]     @relation("CampaignCreator")
    contributions    Contribution[]

    // optional part
    votes        Vote[] // better see “one vote per user per request”
    finalization Finalization[] // Direct access to finalization for faster query
    isBlocked    Boolean        @default(false)
}

enum UserType {
    normal
    admin
}

model Campaign {
    id              String @id @default(uuid())
    contractAddress String @unique // Blockchain address

    // Creator relationship (creatorAddress here = walletAddress in User)
    creator        User   @relation("CampaignCreator", fields: [creatorAddress], references: [walletAddress])
    creatorAddress String

    // Campaign details
    title               String
    description         String?
    minimumContribution Float
    targetAmount        Float
    contributorsCount   Int            @default(0) // Number of contributors
    balance             Float          @default(0) // Current ETH balance
    commission          Float?
    gasCost             Float?
    status              CampaignStatus @default(funding)
    createdAt           DateTime       @default(now())
    updatedAt           DateTime       @updatedAt
    supplement          Bytes? // we could also consider URL to the file than directly like this

    // Campaign relationships
    contributions Contribution[]
    requests      Request[]
    finalizations Finalization[]
}

enum CampaignStatus {
    funding // Campaign is accepting contributions
    completed // Campaign has fulfilled its purpose
    failed // Campaign did not reach target or other failure
}

model Contribution {
    id     String @id @default(uuid())
    txHash String @unique // Blockchain transaction hash

    // Relationships
    contributor        User     @relation(fields: [contributorAddress], references: [walletAddress])
    contributorAddress String
    campaign           Campaign @relation(fields: [campaignAddress], references: [contractAddress])
    campaignAddress    String

    // Contribution details
    amount    Float
    gasCost   Float?
    note      String?
    timestamp DateTime @default(now())
}

model Request {
    id     String @id @default(uuid())
    txHash String @unique // Blockchain transaction hash

    // Relationships
    campaign        Campaign @relation(fields: [campaignAddress], references: [contractAddress])
    campaignAddress String

    // Request details
    reason        String
    amount        Float
    gasCost       Float?
    is_approved   Boolean  @default(false)
    is_finalized  Boolean  @default(false)
    approvalCount Int      @default(0)
    createdAt     DateTime @default(now())
    updatedAt     DateTime @updatedAt

    // Request relationships
    votes        Vote[]
    finalization Finalization? // One-to-one relation with finalization AKA request can only be finalized once

    // Each campaign can only have one request with the same description and amount AKA avoid duplicates, if they wanna ask for the same amount, they have to provide additional reason to why they want extra
    @@unique([campaignAddress, reason, amount])
}

model Vote {
    id     String @id @default(uuid())
    txHash String @unique // Blockchain transaction hash

    // Relationships
    request      Request @relation(fields: [requestId], references: [id])
    requestId    String
    voter        User    @relation(fields: [voterAddress], references: [walletAddress])
    voterAddress String

    // Vote details
    gasCost   Float?
    timestamp DateTime @default(now())

    // Each user can only vote once per request
    @@unique([requestId, voterAddress])
}

model Finalization {
    id     String @id @default(uuid())
    txHash String @unique // Blockchain finalization transaction hash

    // Relationships
    request        Request  @relation(fields: [requestId], references: [id])
    requestId      String   @unique // One-to-one with request
    fundSeeker     User     @relation(fields: [fundSeekerAddr], references: [walletAddress])
    fundSeekerAddr String
    campaign       Campaign @relation(fields: [campaignAddr], references: [contractAddress])
    campaignAddr   String

    // Finalization details
    amount    Float
    gasCost   Float?
    timestamp DateTime @default(now())
}

model ContactMessage {
    id        String   @id @default(uuid())
    name      String
    email     String
    message   String
    createdAt DateTime @default(now())
}

model Admin {
    id            String   @id @default(uuid())
    email         String?  @unique
    walletAddress String?  @unique
    createdAt     DateTime @default(now())
}
